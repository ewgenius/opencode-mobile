# OpenCode Message Parts System

Comprehensive documentation of the message parts architecture, types, behaviors, and rendering system.

---

## Overview

OpenCode uses a **two-tier architecture** for conversations:

- **Messages** contain metadata (role, timestamps, model info, tokens, cost)
- **Parts** contain the actual content (text, tools, files, reasoning, etc.)

This design enables:

- Streaming updates without rewriting entire messages
- Efficient storage and retrieval
- Flexible content types
- Rich tool execution workflows

---

## Part Type Definitions (13 Types)

All part types extend a base schema with `id`, `sessionID`, and `messageID`.

### Core Content Parts

#### 1. TextPart

Regular text content from AI or user.

```typescript
{
  type: "text",
  text: string,
  synthetic?: boolean,  // Generated by system (not AI)
  ignored?: boolean,    // Marked as irrelevant
  time?: {
    start: number,
    end?: number
  },
  metadata?: Record<string, any>
}
```

**Behavior:**

- Supports streaming via delta updates
- Throttled rendering (100ms) to prevent UI thrashing
- Can be marked as "synthetic" for system-generated content

**Rendering:**

- Rendered as Markdown
- Copy button for easy copying
- Project paths are relativized for display

#### 2. ReasoningPart

AI reasoning/thinking process (visible to user).

```typescript
{
  type: "reasoning",
  text: string,
  time: {
    start: number,
    end?: number
  },
  metadata?: Record<string, any>
}
```

**Behavior:**

- Shows AI's thought process
- Supports streaming like TextPart
- Often contains markdown bold titles

**Rendering:**

- Rendered in a distinct style (usually muted/italic)
- Markdown formatting supported

#### 3. FilePart

File attachments with source information.

```typescript
{
  type: "file",
  mime: string,
  filename?: string,
  url: string,
  source?: FilePartSource  // FileSource | SymbolSource | ResourceSource
}

// Source types:
FileSource: { type: "file", path: string, text: { value, start, end } }
SymbolSource: { type: "symbol", path, range, name, kind, text }
ResourceSource: { type: "resource", clientName, uri, text }
```

**Behavior:**

- Images and PDFs shown as attachments
- Other files shown as inline references
- Source text tracks where in the prompt the file was referenced

**Rendering:**

- Images: Thumbnail with lightbox preview
- PDFs: Icon with filename
- Code files: Syntax highlighted inline references

#### 4. AgentPart

Agent invocations (e.g., @agent mentions).

```typescript
{
  type: "agent",
  name: string,
  source?: {
    value: string,
    start: number,
    end: number
  }
}
```

**Behavior:**

- Tracks agent mentions in user messages
- Source tracks position in text for highlighting

**Rendering:**

- Highlighted in user message text
- Shows agent name

---

### Tool & Execution Parts

#### 5. ToolPart

Tool calls with state machine.

```typescript
{
  type: "tool",
  callID: string,
  tool: string,
  state: ToolState,
  metadata?: Record<string, any>
}

// State machine:
type ToolState =
  | { status: "pending", input: Record<string, any>, raw: string }
  | { status: "running", input, title?: string, metadata?, time: { start } }
  | { status: "completed", input, output: string, title, metadata, time: { start, end, compacted? }, attachments?: FilePart[] }
  | { status: "error", input, error: string, metadata?, time: { start, end } }
```

**Behavior:**

- State transitions: pending → running → completed/error
- Can require user permission (shows permission prompt)
- Can ask questions (shows question prompt)
- Supports attachments in completed state

**Rendering:**

- Custom renderers per tool type
- Collapsible card with icon and title
- Shows output when completed
- Shows error state when failed

#### 6. SubtaskPart

Pending child session (for agent delegation).

```typescript
{
  type: "subtask",
  prompt: string,
  description: string,
  agent: string,
  model?: {
    providerID: string,
    modelID: string
  },
  command?: string
}
```

**Behavior:**

- Represents a pending subtask
- Links to child session when created

---

### Control Flow Parts

#### 7. StepStartPart

Marks the beginning of an AI iteration.

```typescript
{
  type: "step-start",
  snapshot?: string  // Filesystem state hash
}
```

**Behavior:**

- Indicates AI is starting a new reasoning step
- Captures filesystem snapshot for tracking changes

#### 8. StepFinishPart

Marks the end of an AI iteration with metrics.

```typescript
{
  type: "step-finish",
  reason: string,
  snapshot?: string,
  cost: number,
  tokens: {
    input: number,
    output: number,
    reasoning: number,
    cache: {
      read: number,
      write: number
    }
  }
}
```

**Behavior:**

- Tracks completion of an AI step
- Records token usage and cost
- Captures final filesystem state

#### 9. SnapshotPart

Filesystem state capture.

```typescript
{
  type: "snapshot",
  snapshot: string  // Hash of filesystem state
}
```

**Behavior:**

- Captures point-in-time filesystem state
- Used for detecting changes between steps

#### 10. PatchPart

File changes summary.

```typescript
{
  type: "patch",
  hash: string,
  files: string[]  // List of changed files
}
```

**Behavior:**

- Summarizes file modifications
- Used in review panel

#### 11. RetryPart

Retry attempt information.

```typescript
{
  type: "retry",
  attempt: number,
  error: APIError,
  time: {
    created: number
  }
}
```

**Behavior:**

- Tracks retry attempts when AI fails
- Shows error information

#### 12. CompactionPart

Context compaction marker.

```typescript
{
  type: "compaction",
  auto: boolean  // True if auto-compacted, false if manual
}
```

**Behavior:**

- Indicates conversation context was compacted
- Pauses normal processing to run compaction

---

## Part Rendering System

### Registry-Based Architecture

Parts are rendered using a registry pattern:

```typescript
// Registry of part renderers
export const PART_MAPPING: Record<string, PartComponent | undefined> = {}

// Register a part renderer
PART_MAPPING["text"] = function TextPartDisplay(props) {
  // Render text part
}

// Render a part
export function Part(props: MessagePartProps) {
  const component = createMemo(() => PART_MAPPING[props.part.type])
  return (
    <Show when={component()}>
      <Dynamic component={component()} part={props.part} message={props.message} />
    </Show>
  )
}
```

### Throttled Rendering for Streaming

Text parts use throttled updates to prevent UI thrashing during streaming:

```typescript
const TEXT_RENDER_THROTTLE_MS = 100;

function createThrottledValue(getValue: () => string) {
  const [value, setValue] = createSignal(getValue());
  let timeout: ReturnType<typeof setTimeout> | undefined;
  let last = 0;

  createEffect(() => {
    const next = getValue();
    const now = Date.now();
    const remaining = TEXT_RENDER_THROTTLE_MS - (now - last);

    if (remaining <= 0) {
      // Immediate update if throttle period passed
      last = now;
      setValue(next);
    } else {
      // Schedule delayed update
      if (timeout) clearTimeout(timeout);
      timeout = setTimeout(() => {
        last = Date.now();
        setValue(next);
      }, remaining);
    }
  });

  return value;
}
```

---

## Tool Rendering System

### Tool Registry

Tools have their own registry for custom rendering:

```typescript
const state: Record<string, { name: string; render?: ToolComponent }> = {};

export function registerTool(input: { name: string; render?: ToolComponent }) {
  state[input.name] = input;
}

export function getTool(name: string) {
  return state[name]?.render;
}

export const ToolRegistry = {
  register: registerTool,
  render: getTool,
};
```

### Built-in Tool Renderers

| Tool          | Icon                  | Behavior                                    |
| ------------- | --------------------- | ------------------------------------------- |
| `read`        | glasses               | Shows file content with syntax highlighting |
| `list`        | bullet-list           | Lists directory contents                    |
| `glob`        | magnifying-glass-menu | Shows file search results                   |
| `grep`        | magnifying-glass-menu | Shows text search results                   |
| `webfetch`    | window-cursor         | Shows web page content                      |
| `task`        | task                  | Shows sub-agent progress with live updates  |
| `bash`        | console               | Shows shell command and output              |
| `edit`        | code-lines            | Shows file diff                             |
| `write`       | code-lines            | Shows new file content                      |
| `apply_patch` | code-lines            | Shows patch application results             |
| `todowrite`   | checklist             | Shows todo list updates                     |
| `todoread`    | checklist             | Shows todo list read results                |
| `question`    | bubble-5              | Shows interactive questions                 |

### BasicTool Component

Most tools use the `BasicTool` wrapper component:

```typescript
interface BasicToolProps {
  icon: IconName;
  trigger: {
    title: string;
    subtitle?: string;
    args?: string[];
    action?: JSX.Element;
  };
  children?: JSX.Element; // Output content
  hideDetails?: boolean;
  defaultOpen?: boolean;
  forceOpen?: boolean;
  locked?: boolean; // Can't be collapsed when true
}
```

---

## Part Behavior & Lifecycle

### Storage Pattern

Parts are stored using a hierarchical key pattern:

```
['part', messageID, partID] → Part
```

Example:

```typescript
// Store a part
Storage.set(['part', 'msg_123', 'part_456'], textPart);

// Get all parts for a message
const parts = Storage.get(['part', 'msg_123']);
```

### Event System

Parts publish events for real-time updates:

```typescript
export const Event = {
  // Part created or updated
  PartUpdated: BusEvent.define(
    'message.part.updated',
    z.object({
      part: Part,
      delta: z.string().optional(), // Only for streaming text
    })
  ),

  // Part removed
  PartRemoved: BusEvent.define(
    'message.part.removed',
    z.object({
      sessionID: z.string(),
      messageID: z.string(),
      partID: z.string(),
    })
  ),
};
```

### Streaming Updates

Text parts support delta streaming:

```typescript
// Server-side: Stream text incrementally
await Session.updatePart({
  part: existingPart,
  delta: 'new text chunk', // Append to existing text
});

// Publishes event with delta
Bus.publish(MessageV2.Event.PartUpdated, {
  part: updatedPart,
  delta: 'new text chunk',
});

// Client-side: Handle delta
bus.subscribe('message.part.updated', ({ part, delta }) => {
  if (delta) {
    // Append delta to existing rendered text
    appendText(part.id, delta);
  } else {
    // Full re-render
    renderPart(part);
  }
});
```

### Tool State Machine

Tools have a sophisticated state lifecycle:

```
┌─────────┐    ┌─────────┐    ┌───────────┐
│ pending │───→│ running │───→│ completed │
└─────────┘    └─────────┘    └───────────┘
                                    │
                                    ↓
                              ┌───────────┐
                              │   error   │
                              └───────────┘
```

**Pending:**

- Tool call received but not yet executing
- May require user permission
- Shows permission prompt if needed

**Running:**

- Tool is executing
- Shows spinner/progress
- May stream intermediate output

**Completed:**

- Tool finished successfully
- Shows output
- May have file attachments

**Error:**

- Tool failed
- Shows error message
- Option to retry

---

## Special Behaviors

### Permission Handling

Tools can require user approval:

```typescript
// Tool part with permission
const toolPart: ToolPart = {
  type: "tool",
  tool: "bash",
  state: { status: "pending", input: { command: "rm -rf /" }, raw: "..." },
  // ...
}

// UI shows permission prompt
<div data-permission="true">
  <ToolDisplay part={toolPart} />
  <PermissionPrompt
    onDeny={() => respond("reject")}
    onAllowOnce={() => respond("once")}
    onAllowAlways={() => respond("always")}
  />
</div>
```

### Question Handling

Tools can ask interactive questions:

```typescript
// Tool asks user for input
const questionRequest: QuestionRequest = {
  sessionID: "...",
  tool: { callID: "...", messageID: "..." },
  question: "Which file should I edit?",
  options: ["file1.ts", "file2.ts"]
}

// UI shows question prompt
<div data-question="true">
  <ToolDisplay part={toolPart} />
  <QuestionPrompt
    question={questionRequest}
    onReply={(answer) => replyToQuestion(answer)}
  />
</div>
```

### Path Relativization

For better UX, absolute paths are relativized to project root:

```typescript
function relativizeProjectPaths(text: string, directory?: string) {
  if (!text || !directory) return text;
  return text.split(directory).join(''); // Remove project path prefix
}

// Before: /home/user/projects/myapp/src/index.ts
// After:  src/index.ts
```

---

## SessionTurn Component

The `SessionTurn` component manages a complete conversation turn (user message + assistant response):

```typescript
function SessionTurn(props: { sessionID: string; messageID: string }) {
  // Get user message parts
  const userParts = createMemo(() => store.part[props.messageID] ?? [])

  // Get assistant response messages (children of user message)
  const assistantMessages = createMemo(() =>
    store.message[props.sessionID]
      ?.filter(m => m.role === "assistant" && m.parentID === props.messageID)
  )

  // Compute streaming status
  const isStreaming = createMemo(() => {
    const status = store.session_status[props.sessionID]
    return status?.type === "working"
  })

  // Auto-scroll during streaming
  createAutoScroll(() => isStreaming())

  return (
    <div class="session-turn">
      <UserMessageDisplay parts={userParts()} />
      <For each={assistantMessages()}>
        {msg => <AssistantMessageDisplay message={msg} parts={store.part[msg.id]} />}
      </For>
    </div>
  )
}
```

---

## Key Files

| Component             | Path                                           |
| --------------------- | ---------------------------------------------- |
| Part Type Definitions | `/packages/opencode/src/session/message-v2.ts` |
| Part Rendering        | `/packages/ui/src/components/message-part.tsx` |
| Tool Components       | `/packages/ui/src/components/basic-tool.tsx`   |
| Session Turn          | `/packages/ui/src/components/session-turn.tsx` |
| SDK Types             | `/packages/sdk/js/src/v2/gen/types.gen.ts`     |

---

## Summary

The message parts system provides:

1. **13 distinct part types** for all conversation content
2. **Two-tier storage** separating metadata from content
3. **Streaming support** via delta updates
4. **Registry-based rendering** for extensibility
5. **State machine tooling** with permission and question handling
6. **Throttled rendering** for performance during streaming
7. **Path relativization** for better UX

This architecture enables rich, interactive AI conversations with real-time updates and flexible content types.
